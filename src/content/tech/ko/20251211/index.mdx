---
title: 'í¬íŠ¸í´ë¦¬ì˜¤ v5 ê°œí¸í¸ (LLM + RAG + Embedding AIë¥¼ ê³ë“¤ì¸...)'
description: 'í¬íŠ¸í´ë¦¬ì˜¤ v5 ê°œí¸ê³¼ í•¨ê»˜ ë„ì…í•œ RAG ê¸°ë°˜ AI ì±„íŒ… ì‹œìŠ¤í…œì˜ êµ¬í˜„ ê³¼ì •ì„ ê³µìœ í•©ë‹ˆë‹¤!'
isDraft: true
author: 'Dewdew'
language: 'ko'
publishedDate: 2025-12-11
tags: ['nuxt4', 'nuxt', 'vue3', 'typescript', 'rag', 'llm', 'embedding', 'ai', 'openai', 'supabase', 'vector search', 'nuxt4 blog', 'ai chat', 'portfolio']
authorContact: 'yeonju.lee1005@kakao.com'
canonicalURL: 'https://www.dewdew.world'
avatar: '/images/dewdew_world.webp'
avatarAlt: 'dewdew'
cover: '/tech/cover/20251211.png'
coverAlt: 'cover Image'
---

> í¬íŠ¸í´ë¦¬ì˜¤ ì‚¬ì´íŠ¸ v5ë¥¼ ê°œí¸í•˜ë©° ê°€ì¥ í° ë³€í™”ëŠ” ë°”ë¡œ **RAG ê¸°ë°˜ ìê¸°ì†Œê°œ AI ì±„íŒ… ê¸°ëŠ¥**ì˜ ë„ì…ì´ì—ˆìŠµë‹ˆë‹¤!<br />
> ì´ë²ˆ ê¸€ì—ì„œëŠ” LLM, RAG, Embeddingì„ í™œìš©í•˜ì—¬ êµ¬í˜„í•œ í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì½”ë“œì™€ í•¨ê»˜ ìƒì„¸íˆ ê³µìœ í•©ë‹ˆë‹¤!<br />
> ì‹¤ì œ ë™ì‘ì€ [ë“€ë“€ Dev](https://www.dewdew.dev)ì—ì„œ ì‚¬ìš©í•˜ì‹¤ ìˆ˜ ìˆì–´ìš”!ğŸ¤¨

# ë“¤ì–´ê°€ê¸° ì•ì„œ,

í¬íŠ¸í´ë¦¬ì˜¤ ì‚¬ì´íŠ¸ v5ë¥¼ ê°œí¸í•˜ë©´ì„œ ê°€ì¥ í° ëª©í‘œëŠ” ë‘ ê°€ì§€ì˜€ì–´ìš”!

1. **AI ê¸°ëŠ¥ ë„ì…**: ë°©ë¬¸ìì™€ ì§ì ‘ ëŒ€í™”í•  ìˆ˜ ìˆëŠ” ìê¸°ì†Œê°œ AI ì±„íŒ… ê¸°ëŠ¥ êµ¬í˜„
2. **ê°„ë‹¨í•œ í¬íŠ¸í´ë¦¬ì˜¤ ì‚¬ì´íŠ¸ë¡œ ë³€ëª¨**: ë³µì¡í–ˆë˜ ì´ì „ ë²„ì „ì„ ë‹¨ìˆœí™”í•˜ê³ , í•µì‹¬ ê¸°ëŠ¥ì— ì§‘ì¤‘

íŠ¹íˆ ì²« ë²ˆì§¸ ëª©í‘œì¸ AI ê¸°ëŠ¥ì€ ë‹¨ìˆœíˆ ChatGPT APIë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ì œ `ê°œì¸ ë°ì´í„°`ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì •í™•í•œ ë‹µë³€ì„ ì œê³µí•  ìˆ˜ ìˆë„ë¡ `RAG(Retrieval-Augmented Generation)` ì‹œìŠ¤í…œì„ ì§ì ‘ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤!<br />
ë˜í•œ, `vector DB`ì™€ `Embedding AI`ë¥¼ í™œìš©í•´ ì§ˆë¬¸ìì˜ ì§ˆë¬¸ê³¼ ë‚´ ê°œì¸ ë°ì´í„°ë¥¼ ì„ë² ë”© ê¸°ë°˜ìœ¼ë¡œ ìœ ì‚¬ë„ ê²€ìƒ‰í•˜ì—¬, ê°€ì¥ ê´€ë ¨ì„± ë†’ì€ ì •ë³´ë¥¼ ë‹µë³€í•  ìˆ˜ ìˆë„ë¡ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤!

ì´ë²ˆ ê¸€ì—ì„œëŠ” ì´ëŸ¬í•œ RAG ì‹œìŠ¤í…œì˜ í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì½”ë“œì™€ í•¨ê»˜ ìì„¸íˆ ì„¤ëª…í•´ë“œë¦¬ë ¤ê³  í•©ë‹ˆë‹¤!


# í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜ ê°œìš”

ì „ì²´ ì‹œìŠ¤í…œì€ ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì¡°ë¡œ êµ¬ì„±ë˜ì–´ ìˆì–´ìš”!

```sh
dewdew_v5/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ composables/chat/
â”‚   â”‚   â””â”€â”€ useChat.ts              # í´ë¼ì´ì–¸íŠ¸ ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬
â”‚   â””â”€â”€ pages/ai/
â”‚       â””â”€â”€ index.vue                # AI ì±„íŒ… í˜ì´ì§€
â”œâ”€â”€ server/
â”‚   â””â”€â”€ api/chat/
â”‚       â””â”€â”€ index.post.ts            # Nuxt ì„œë²„ API (í”„ë¡ì‹œ)
â””â”€â”€ supabase/
    â””â”€â”€ functions/
        â”œâ”€â”€ dewdew-rag-portfolio/    # RAG ë©”ì¸ Edge Function
        â”œâ”€â”€ initialize-embeddings/   # ì„ë² ë”© ì´ˆê¸°í™” Function
        â””â”€â”€ _shared/
            â”œâ”€â”€ rag.ts               # RAG í•µì‹¬ ë¡œì§
            â”œâ”€â”€ embeddings.ts        # ì„ë² ë”© ìƒì„±
            â”œâ”€â”€ embedding-manager.ts # ì„ë² ë”© ê´€ë¦¬
            â””â”€â”€ document-builder.ts  # ë¬¸ì„œ í…ìŠ¤íŠ¸ ë³€í™˜
```

`í•µì‹¬ íë¦„`
1. í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì‚¬ìš©ì ë©”ì‹œì§€ ì…ë ¥
2. `Nuxt ì„œë²„ API`ê°€ `Supabase Edge Function`ìœ¼ë¡œ í”„ë¡ì‹œ
3. `Edge Function`ì—ì„œ `RAG` ì‹œìŠ¤í…œì´ ê´€ë ¨ ë°ì´í„° ê²€ìƒ‰
4. LLMì´ ê²€ìƒ‰ëœ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë‹µë³€ ìƒì„±
5. `ìŠ¤íŠ¸ë¦¬ë°`ìœ¼ë¡œ ì‹¤ì‹œê°„ ì‘ë‹µ ì „ë‹¬


# `RAG` ì‹œìŠ¤í…œì˜ í•µì‹¬: `í•˜ì´ë¸Œë¦¬ë“œ` ê²€ìƒ‰ ì „ëµ

`RAG` ì‹œìŠ¤í…œì˜ ê°€ì¥ ì¤‘ìš”í•œ ë¶€ë¶„ì€ ë°”ë¡œ `"ì–´ë–»ê²Œ ê´€ë ¨ ë°ì´í„°ë¥¼ ì°¾ì„ ê²ƒì¸ê°€"`ì…ë‹ˆë‹¤!

ì €ëŠ” `í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ì „ëµ`ì„ ì±„íƒí–ˆì–´ìš”:
1. `1ì°¨: í‚¤ì›Œë“œ ë§¤ì¹­` (ë¹ ë¥´ê³  ì •í™•)
2. `2ì°¨: ë²¡í„° ê²€ìƒ‰` (ì˜ë¯¸ ê¸°ë°˜, í‚¤ì›Œë“œ ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ)

ì´ë ‡ê²Œ í•˜ë©´ ëª…í™•í•œ í‚¤ì›Œë“œê°€ ìˆëŠ” ì§ˆë¬¸ì€ ë¹ ë¥´ê²Œ ì²˜ë¦¬í•˜ê³ , ì¶”ìƒì ì´ê±°ë‚˜ `ì˜ë¯¸ ê¸°ë°˜` ì§ˆë¬¸ì€ `ë²¡í„° ê²€ìƒ‰`ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆì–´ìš”!

## 1. í‚¤ì›Œë“œ ë§¤ì¹­ ë¡œì§

ë¨¼ì € í‚¤ì›Œë“œ ë§¤ì¹­ë¶€í„° ì‚´í´ë³¼ê²Œìš”!

```typescript
// /supabase/functions/_shared/rag.ts

// í‚¤ì›Œë“œ ë§¤ì¹­ í—¬í¼
const matchKeywords = (text: string, keywords: string[]): boolean => {
  const lowerText = text.toLowerCase()
  return keywords.some(keyword => lowerText.includes(keyword))
}

// RAG: ì§ˆë¬¸ ê¸°ë°˜ ë°ì´í„° ê²€ìƒ‰ (í•˜ì´ë¸Œë¦¬ë“œ: í‚¤ì›Œë“œ ë§¤ì¹­ + ë²¡í„° ê²€ìƒ‰)
export const fetchRelevantData = async (query: string): Promise<RAGContext> => {
  const supabase = getSupabaseClient()
  const context: RAGContext = {}
  const queryLower = query.toLowerCase()

  // 1. ë¨¼ì € í‚¤ì›Œë“œ ë§¤ì¹­ ì‹œë„
  const keywordMatched = await tryKeywordMatching(queryLower, context, supabase)

  // 2. í‚¤ì›Œë“œ ë§¤ì¹­ ì„±ê³µí•˜ê³  ë°ì´í„°ê°€ ì¶©ë¶„í•˜ë©´ ë°”ë¡œ ë°˜í™˜
  if (keywordMatched && hasRelevantData(context)) {
    return context
  }

  // 3. í‚¤ì›Œë“œ ë§¤ì¹­ ì‹¤íŒ¨ ë˜ëŠ” ë°ì´í„° ë¶€ì¡± â†’ ë²¡í„° ê²€ìƒ‰ ì‹œë„
  try {
    const queryEmbedding = await getEmbedding(query, 'openai')

    const { data: matches, error } = await supabase.rpc('match_documents', {
      query_embedding: `[${queryEmbedding.join(',')}]`,
      match_threshold: 0.7,
      match_count: 5,
    })

    if (error) {
      console.error('Vector search error:', error)
    }
    else if (matches && matches.length > 0) {
      // ë²¡í„° ê²€ìƒ‰ ê²°ê³¼ë¡œ ì»¨í…ìŠ¤íŠ¸ ë³´ê°•
      await enrichContextFromVectorMatches(context, matches, supabase)
    }
  }
  catch (error) {
    console.error('Vector search failed, using keyword matching results only:', error)
    // ë²¡í„° ê²€ìƒ‰ ì‹¤íŒ¨í•´ë„ í‚¤ì›Œë“œ ë§¤ì¹­ ê²°ê³¼ëŠ” ë°˜í™˜
  }

  return context
}
```

`í‚¤ì›Œë“œ ë§¤ì¹­`ì€ ë‹¤ì–‘í•œ ì§ˆë¬¸ íŒ¨í„´ì„ ê°ì§€í•˜ê³  ìˆì–´ìš”.

```typescript
// /supabase/functions/_shared/rag.ts

// í”„ë¡œí•„
if (matchKeywords(queryLower, ['ìê¸°ì†Œê°œ', 'ëˆ„êµ¬', 'í”„ë¡œí•„', 'ì†Œê°œ', 'ì´ë¦„', ...])) {
  const { data } = await supabase
    .schema('resume')
    .from('profile')
    .select('*')
    .single<Profile>()
  context.profile = data
  matched = true
}

// ê²½ë ¥
if (matchKeywords(queryLower, ['ê²½ë ¥', 'íšŒì‚¬', 'ì¼', 'ì§ì¥', ...])) {
  const { data } = await supabase
    .schema('resume')
    .from('experience')
    .select('*')
    .order('order_index', { ascending: false })
    .returns<Experience[]>()
  context.experience = data
  matched = true
}

// ìŠ¤í‚¬
if (matchKeywords(queryLower, ['ìŠ¤í‚¬', 'ê¸°ì—¬', 'ê¸°ìˆ ', 'ìŠ¤íƒ', ...])) {
  const { data } = await supabase
    .schema('resume')
    .from('skills')
    .select('*')
    .order('order_index', { ascending: false })
    .returns<Skill[]>()
  context.skills = data
  matched = true
}
```

ì´ë ‡ê²Œ `í‚¤ì›Œë“œ ë§¤ì¹­`ì„ ë¨¼ì € ì‹œë„í•˜ë©´, ëª…í™•í•œ ì§ˆë¬¸ì— ëŒ€í•´ì„œëŠ” `ë²¡í„° ê²€ìƒ‰ ë¹„ìš© ì—†ì´ ë¹ ë¥´ê²Œ` ì²˜ë¦¬í•  ìˆ˜ ìˆì–´ìš”!

## 2. ë²¡í„° ê²€ìƒ‰ ë¡œì§

`í‚¤ì›Œë“œ ë§¤ì¹­`ì´ ì‹¤íŒ¨í•˜ê±°ë‚˜ ë°ì´í„°ê°€ ë¶€ì¡±í•œ ê²½ìš°, `ë²¡í„° ê²€ìƒ‰`ì„ í†µí•´ `ì˜ë¯¸ ê¸°ë°˜`ìœ¼ë¡œ ê´€ë ¨ ë°ì´í„°ë¥¼ ì°¾ì•„ìš”!

```typescript
// /supabase/functions/_shared/rag.ts

// ë²¡í„° ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì»¨í…ìŠ¤íŠ¸ë¡œ ë³€í™˜
const enrichContextFromVectorMatches = async (
  context: RAGContext,
  matches: Array<{
    document_type: string
    document_id: string
    similarity: number
    metadata: any
  }>,
  supabase: ReturnType<typeof getSupabaseClient>,
): Promise<void> => {
  // ìœ ì‚¬ë„ê°€ ë†’ì€ ìˆœìœ¼ë¡œ ì •ë ¬
  const sortedMatches = matches.sort((a, b) => b.similarity - a.similarity)

  // ì´ë¯¸ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë§¤í•‘
  const hasDataMap: Record<string, () => boolean> = {
    ...,
    experience: () => !!(context.experience && context.experience.length > 0),
    skills: () => !!(context.skills && context.skills.length > 0),
    project: () => !!(context.projects && context.projects.length > 0),
    education: () => !!(context.education && context.education.length > 0),
    ...
  }

  // í•„í„°ë§: ìœ ì‚¬ë„ ì²´í¬ ë° ì´ë¯¸ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
  const validMatches = sortedMatches.filter((match) => {
    // ìœ ì‚¬ë„ê°€ ë‚®ìœ¼ë©´ ìŠ¤í‚µ (0.7 ë¯¸ë§Œ)
    if (match.similarity < 0.7) {
      return false
    }
    // ì´ë¯¸ í‚¤ì›Œë“œ ë§¤ì¹­ìœ¼ë¡œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ìŠ¤í‚µ
    const hasData = hasDataMap[match.document_type]
    if (hasData && hasData()) {
      return false
    }
    return true
  })

  // ê° ë§¤ì¹˜ë¥¼ ë³‘ë ¬ë¡œ ì²˜ë¦¬
  await Promise.all(validMatches.map(async (match) => {
    try {
      const handler = handlers[match.document_type]
      if (handler) {
        await handler(match)
      }
    }
    catch (error) {
      console.error(`Error enriching context for ${match.document_type}:`, error)
    }
  }))
}
```

`í•µì‹¬ í¬ì¸íŠ¸`
- ìœ ì‚¬ë„ `0.7 ì´ìƒ`ë§Œ ì‚¬ìš© (ë„ˆë¬´ ë‚®ì€ ìœ ì‚¬ë„ëŠ” ë…¸ì´ì¦ˆ)
- ì´ë¯¸ í‚¤ì›Œë“œ ë§¤ì¹­ìœ¼ë¡œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ `ì¤‘ë³µ ë°©ì§€`
- ê° ë¬¸ì„œ íƒ€ì…ë³„ë¡œ `ë³‘ë ¬ ì²˜ë¦¬`í•˜ì—¬ ì„±ëŠ¥ ìµœì í™”


# `Embedding` ìƒì„± ë° ê´€ë¦¬

`ë²¡í„° ê²€ìƒ‰`ì„ ìœ„í•´ì„œëŠ” ë¨¼ì € ëª¨ë“  ë¬¸ì„œë¥¼ `ì„ë² ë”©`ìœ¼ë¡œ ë³€í™˜í•´ì•¼ í•´ìš”!

## 1. ë¬¸ì„œ í…ìŠ¤íŠ¸ ë³€í™˜

ë°ì´í„°ë² ì´ìŠ¤ì˜ êµ¬ì¡°í™”ëœ ë°ì´í„°ë¥¼ `ì„ë² ë”© ìƒì„±ìš© í…ìŠ¤íŠ¸`ë¡œ ë³€í™˜í•´ìš”!

```typescript
// /supabase/functions/_shared/document-builder.ts

/**
 * í”„ë¡œí•„ ë°ì´í„°ë¥¼ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜
 */
export const buildProfileText = (profile: Profile): string => {
  const fieldMap: Record<string, { label: string, value: string | null | undefined }> = {
    full_name: { label: 'ì´ë¦„', value: profile.full_name },
    title: { label: 'ì§ì±…', value: profile.title },
    bio: { label: 'ì†Œê°œ', value: profile.bio },
    ...
  }

  const parts: string[] = Object.entries(fieldMap)
    .filter(([, { value }]) => value)
    .map(([, { label, value }]) => `${label}: ${value}`)

  if (profile.weaknesses && profile.weaknesses.length > 0) {
    parts.push(`ê°œì„ ì : ${profile.weaknesses.join(', ')}`)
  }

  return parts.join('\n')
}

/**
 * ê²½ë ¥ ë°ì´í„°ë¥¼ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜
 */
export const buildExperienceText = (experiences: Experience[]): string => {
  return experiences.map((exp) => {
    const fieldMap: Record<string, { label: string, value: string | null | undefined }> = {
      company_name: { label: 'íšŒì‚¬', value: exp.company_name },
      position: { label: 'ì§ì±…', value: exp.position },
      ...
    }

    const parts: string[] = Object.entries(fieldMap)
      .filter(([, { value }]) => !!value)
      .map(([, { label, value }]) => `${label}: ${value}`)

    parts.push(`ê¸°ê°„: ${exp.start_date} ~ ${exp.end_date || 'í˜„ì¬'}`)
    return parts.join('\n')
  }).join('\n\n')
}
```

## 2. ì„ë² ë”© ìƒì„± ë° ì €ì¥

ë³€í™˜ëœ í…ìŠ¤íŠ¸ë¥¼ `OpenAI Embedding API`ë¡œ `ë²¡í„°í™”`í•˜ê³  ì €ì¥í•´ìš”!

```typescript
// /supabase/functions/_shared/embeddings.ts

/**
 * OpenAI Embeddings API
 */
const getOpenAIEmbedding = async (text: string): Promise<number[]> => {
  const apiKey = Deno.env.get('API_KEY')

  if (!apiKey) {
    throw new Error('API_KEY is required')
  }

  const response = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'text-embedding-3-small',
      input: text,
      dimensions: 768, // ë°ì´í„°ë² ì´ìŠ¤ ë²¡í„° ì°¨ì›ì— ë§ì¶¤
    }),
  })

  if (!response.ok) {
    const error = await response.text()
    throw new Error(`OpenAI API error: ${response.status} - ${error}`)
  }

  const data = await response.json()
  return data.data[0].embedding
}
```

```typescript
// /supabase/functions/_shared/embedding-manager.ts

/**
 * ë¬¸ì„œ ì„ë² ë”© ì €ì¥
 */
const saveDocumentEmbedding = async (
  documentType: string,
  documentId: string,
  content: string,
  embedding: number[],
  metadata?: Record<string, any>,
): Promise<void> => {
  const supabase = getSupabaseClient()

  const { error } = await supabase
    .schema('resume')
    .from('document_embeddings')
    .upsert({
      document_type: documentType,
      document_id: documentId,
      content,
      embedding: vectorToArray(embedding),
      metadata: metadata || {},
      updated_at: new Date().toISOString(),
    }, {
      onConflict: 'document_type,document_id',
    })

  if (error) {
    console.error(`Failed to save embedding for ${documentType}:${documentId}`, error)
    throw error
  }
}

/**
 * í”„ë¡œí•„ ì„ë² ë”© ìƒì„± ë° ì €ì¥
 */
export const createProfileEmbedding = async (profile: Profile): Promise<void> => {
  const content = buildProfileText(profile)
  const embedding = await getEmbedding(content, 'openai')

  await saveDocumentEmbedding(
    'profile',
    profile.id,
    content,
    embedding,
    { full_name: profile.full_name, title: profile.title },
  )
}
```

## 3. ì„ë² ë”© ì´ˆê¸°í™”

ëª¨ë“  ë¬¸ì„œì˜ ì„ë² ë”©ì„ í•œ ë²ˆì— ìƒì„±í•˜ëŠ” `Edge Function` ê¸°ëŠ¥ì´ì—ìš”!

```typescript
// /supabase/functions/embeddings/index.ts

import { initializeAllEmbeddings } from '../_shared/embedding-manager.ts'

serve(async (req: Request): Promise<Response> => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  if (req.method !== 'POST') {
    return new Response(
      JSON.stringify({ error: 'Method not allowed' }),
      { status: 405, headers: { ...corsHeaders, 'Content-Type': 'application/json' } },
    )
  }

  try {
    console.log('Starting embedding initialization...')
    await initializeAllEmbeddings()

    return new Response(
      JSON.stringify({
        success: true,
        message: 'All embeddings initialized successfully',
      }),
      {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      },
    )
  }
  catch (error) {
    console.error('Initialization error:', error)

    return new Response(
      JSON.stringify({
        error: error instanceof Error ? error.message : 'Unknown error',
      }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      },
    )
  }
})
```

ì¤‘ìš”í•œ ì ì€, ê°œì¸ ë°ì´í„°ê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ `ë°˜ë“œì‹œ` `embeddings` `Edge Function`ì„ ë‹¤ì‹œ ì‹¤í–‰í•´ì•¼ í•´ìš”!<br />
ì´ìœ ëŠ” ë²¡í„° ê²€ìƒ‰ì´ ìµœì‹  ë°ì´í„°ë¥¼ ë°˜ì˜í•˜ë ¤ë©´ ì„ë² ë”©ì´ ìµœì‹  ìƒíƒœì—¬ì•¼ í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤!


# LLM í†µí•© ë° ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ

`RAG`ë¡œ ê²€ìƒ‰í•œ ë°ì´í„°ë¥¼ `LLM`ì— ì „ë‹¬í•˜ì—¬ ë‹µë³€ì„ ìƒì„±í•´ìš”!

## 1. ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ êµ¬ì„±

ê²€ìƒ‰ëœ ì»¨í…ìŠ¤íŠ¸ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ë¥¼ ë™ì ìœ¼ë¡œ ìƒì„±í•´ìš”!

```typescript
// /supabase/functions/rag/index.ts

// ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ìƒì„±
const buildSystemPrompt = (
  settings: AISettingsMap,
  context: RAGContext,
  componentType: ComponentType,
  contextSummary: string = '',
): string => {
  const ownerName = settings.owner_name ?? 'ì´ì—°ì£¼(ë“€ë“€)'
  const personality = settings.personality ?? 'ì¹œê·¼í•˜ê³  ì—´ì •ì ì¸ Software Engineer'
  const speakingStyle = settings.speaking_style ?? 'ì¡´ëŒ“ë§ì´ë©´ì„œ ì „ë¬¸ì ì´ê³  ì¹œê·¼í•˜ê²Œ'

  const hasData = Object.values(context).some(v => v !== null && v !== undefined)
  const dataContext = hasData
    ? `\n\n[ë‚´ ì •ë³´ - ë°˜ë“œì‹œ ì´ ë°ì´í„° ê¸°ë°˜ìœ¼ë¡œë§Œ ë‹µë³€]\n${JSON.stringify(context, null, 2)}`
    : ''

  return `ë‹¹ì‹ ì€ "${ownerName}"ì…ë‹ˆë‹¤. í¬íŠ¸í´ë¦¬ì˜¤ ì‚¬ì´íŠ¸ì— ë°©ë¬¸í•œ ì‚¬ëŒê³¼ ì§ì ‘ ëŒ€í™”í•˜ê³  ìˆìŠµë‹ˆë‹¤.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
[ì •ì²´ì„±]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
[ë‚˜ì˜ ì„±ê²© ë° ìƒì„¸ ì†Œê°œ]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
[ë§íˆ¬ ìŠ¤íƒ€ì¼]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
[ì‘ë‹µ ê·œì¹™]
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ë°˜ë“œì‹œ ì œê³µëœ [ë‚´ ì •ë³´] ë°ì´í„°ë§Œ ì‚¬ìš©í•´ì„œ ë‹µë³€í•˜ì„¸ìš”.
...

${dataContext}`
}
```

## 2. ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ì²˜ë¦¬

ì‹¤ì‹œê°„ìœ¼ë¡œ ë‹µë³€ì„ `ìŠ¤íŠ¸ë¦¬ë°`í•˜ì—¬ ì‚¬ìš©ì ê²½í—˜ì„ í–¥ìƒì‹œí‚¤ê³  ìˆì–´ìš”!

```typescript
// /supabase/functions/dewdew-rag-portfolio/index.ts

// SSE ìŠ¤íŠ¸ë¦¼ ìƒì„± (ë©€í‹° í”„ë¡œë°”ì´ë” ì§€ì›)
const createSSEStream = (
  aiStream: ReadableStream<Uint8Array>,
  componentType: ComponentType,
  context: RAGContext,
  provider: ModelProvider,
): ReadableStream<Uint8Array> => {
  const encoder = new TextEncoder()
  const decoder = new TextDecoder()

  return new ReadableStream({
    async start(controller) {
      // 1. ë©”íƒ€ë°ì´í„° ë¨¼ì € ì „ì†¡
      const metadata: StreamMetadata = {
        type: 'metadata',
        componentType,
        data: context,
      }
      const metadataStr = `data: ${JSON.stringify(metadata)}\n\n`
      controller.enqueue(encoder.encode(metadataStr))

      // 2. AI ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ (í”„ë¡œë°”ì´ë”ë³„)
      const reader = aiStream.getReader()

      try {
        while (true) {
          const { done, value } = await reader.read()
          if (done) break

          const chunk = decoder.decode(value, { stream: true })
          const lines = chunk
            .split('\n')
            .filter(line => line.trim() !== '')

          for (const line of lines) {
            // OpenAI í˜•ì‹
            if (provider === 'openai' && line.startsWith('data: ')) {
              const jsonStr = line.slice(6).trim()

              if (jsonStr === '[DONE]') {
                controller.enqueue(encoder.encode('data: [DONE]\n\n'))
                continue
              }

              try {
                const parsed = JSON.parse(jsonStr)
                const content = parsed.choices?.[0]?.delta?.content

                if (content) {
                  const textChunk: StreamTextChunk = {
                    type: 'text',
                    content,
                  }
                  controller.enqueue(
                    encoder.encode(`data: ${JSON.stringify(textChunk)}\n\n`),
                  )
                }
              }
              catch {
                // JSON íŒŒì‹± ì‹¤íŒ¨ëŠ” ë¬´ì‹œ
              }
            }
          }
        }
      }
      catch (error) {
        console.error('Stream processing error:', error)
        controller.error(error)
      }
      finally {
        reader.releaseLock()
        controller.close()
      }
    },
  })
}
```

## 3. í´ë¼ì´ì–¸íŠ¸ ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬

í´ë¼ì´ì–¸íŠ¸ì—ì„œëŠ” `ReadableStream`ì„ íŒŒì‹±í•˜ì—¬ ì‹¤ì‹œê°„ìœ¼ë¡œ í…ìŠ¤íŠ¸ë¥¼ í‘œì‹œí•´ìš”!

```typescript
// /app/composables/chat/useChat.ts

// ìŠ¤íŠ¸ë¦¬ë° íŒŒì‹± ê³µí†µ í•¨ìˆ˜
const parseStreamResponse = async (
  response: Response,
  onText: (text: string) => void,
  onMetadata?: (type: ComponentType, data: Record<string, any>) => void,
) => {
  const reader = response.body?.getReader()
  const decoder = new TextDecoder()

  if (!reader) throw new Error('No reader available')

  let buffer = ''

  try {
    while (true) {
      const { done, value } = await reader.read()
      if (done) break

      const chunk = decoder.decode(value, { stream: true })
      buffer += chunk

      // ì™„ì „í•œ ë¼ì¸ë§Œ ì²˜ë¦¬ (ê°œí–‰ ë¬¸ìë¡œ ë¶„ë¦¬)
      const lines = buffer.split('\n')
      // ë§ˆì§€ë§‰ ë¶ˆì™„ì „í•œ ë¼ì¸ì€ ë²„í¼ì— ìœ ì§€
      buffer = lines.pop() || ''

      for (const line of lines) {
        if (!line.startsWith('data: ')) continue

        const jsonStr = line.slice(6).trim()
        if (jsonStr === '' || jsonStr === '[DONE]') continue

        try {
          const parsed = JSON.parse(jsonStr) as StreamMetadata | StreamTextChunk

          if (parsed.type === 'metadata' && onMetadata) {
            const metadata = parsed as StreamMetadata
            onMetadata(metadata.componentType, metadata.data)
          }

          if (parsed.type === 'text') {
            onText((parsed as StreamTextChunk).content)
          }
        }
        catch (error) {
          // JSON íŒŒì‹± ì‹¤íŒ¨ ì‹œ ë¡œê·¸ ì¶œë ¥
          console.warn('[useChat] âš ï¸ JSON parse error:', error)
        }
      }
    }
  }
  finally {
    reader.releaseLock()
  }
}
```


# í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ìš”ì•½

ì „ì²´ ì‹œìŠ¤í…œì˜ í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì •ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì•„ìš”!

## 1. í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ì „ëµ

| ë‹¨ê³„ | ë°©ë²• | ëª©ì  | ì„±ëŠ¥ |
|------|------|------|------|
| **1ì°¨** | í‚¤ì›Œë“œ ë§¤ì¹­ | ëª…í™•í•œ í‚¤ì›Œë“œê°€ ìˆëŠ” ì§ˆë¬¸ ë¹ ë¥´ê²Œ ì²˜ë¦¬ | ë¹ ë¦„ (DB ì¿¼ë¦¬ë§Œ) |
| **2ì°¨** | ë²¡í„° ê²€ìƒ‰ | ì˜ë¯¸ ê¸°ë°˜ ì§ˆë¬¸ ì²˜ë¦¬ | ëŠë¦¼ (ì„ë² ë”© ìƒì„± + ë²¡í„° ê²€ìƒ‰) |

`ì¥ì `
- ëª…í™•í•œ ì§ˆë¬¸ì€ í‚¤ì›Œë“œ ë§¤ì¹­ìœ¼ë¡œ `ë¹ ë¥´ê²Œ` ì²˜ë¦¬
- ì¶”ìƒì ì¸ ì§ˆë¬¸ì€ ë²¡í„° ê²€ìƒ‰ìœ¼ë¡œ `ì˜ë¯¸ ê¸°ë°˜` ì²˜ë¦¬
- ë¹„ìš© ìµœì í™” (í‚¤ì›Œë“œ ë§¤ì¹­ ì„±ê³µ ì‹œ ë²¡í„° ê²€ìƒ‰ ìŠ¤í‚µ)

## 2. ì„ë² ë”© ê´€ë¦¬ ì „ëµ

| ì‘ì—… | ì‹œì  | ë°©ë²• |
|------|------|------|
| `ì´ˆê¸°í™”` | ë°ì´í„° ë³€ê²½ ì‹œ | `embeddings` Edge Function ì‹¤í–‰ |
| `ì €ì¥` | ì„ë² ë”© ìƒì„± í›„ | `document_embeddings` í…Œì´ë¸”ì— upsert |
| `ê²€ìƒ‰` | ì§ˆë¬¸ ì‹œ | PostgreSQL `match_documents` RPC í•¨ìˆ˜ |

`ì£¼ì˜ì‚¬í•­`
- ë°ì´í„° ë³€ê²½ ì‹œ `ë°˜ë“œì‹œ` ì„ë² ë”© ì¬ìƒì„± í•„ìš”
- ì„ë² ë”©ì´ ìµœì‹  ìƒíƒœê°€ ì•„ë‹ˆë©´ ë²¡í„° ê²€ìƒ‰ ê²°ê³¼ê°€ ë¶€ì •í™•í•  ìˆ˜ ìˆìŒ

## 3. ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ ì „ëµ

| ë‹¨ê³„ | ë‚´ìš© | ëª©ì  |
|------|------|------|
| `1. ë©”íƒ€ë°ì´í„° ì „ì†¡` | ì»´í¬ë„ŒíŠ¸ íƒ€ì… ë° ë°ì´í„° | UI ì»´í¬ë„ŒíŠ¸ ë Œë”ë§ ì¤€ë¹„ |
| `2. í…ìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¬ë°` | ì‹¤ì‹œê°„ í…ìŠ¤íŠ¸ ì²­í¬ | ì‚¬ìš©ì ê²½í—˜ í–¥ìƒ |
| `3. ì™„ë£Œ ì‹ í˜¸` | `[DONE]` ì „ì†¡ | ìŠ¤íŠ¸ë¦¬ë° ì¢…ë£Œ ì²˜ë¦¬ |

`ì¥ì `
- ì‚¬ìš©ìê°€ ë‹µë³€ì„ ê¸°ë‹¤ë¦¬ëŠ” ì‹œê°„ ë‹¨ì¶•
- ì‹¤ì‹œê°„ìœ¼ë¡œ í…ìŠ¤íŠ¸ê°€ í‘œì‹œë˜ì–´ ë” ìì—°ìŠ¤ëŸ¬ìš´ ëŒ€í™” ëŠë‚Œ


# ë§ˆë¬´ë¦¬

ì´ë²ˆ ê¸€ì—ì„œëŠ” í¬íŠ¸í´ë¦¬ì˜¤ v5ì— ë„ì…í•œ `LLM + RAG + Embedding` ê¸°ë°˜ ìê¸°ì†Œê°œ AIì˜ í•µì‹¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì½”ë“œì™€ í•¨ê»˜ ìƒì„¸íˆ ê³µìœ í–ˆìŠµë‹ˆë‹¤!

`í•µì‹¬ í¬ì¸íŠ¸`
1. `í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ì „ëµ`: í‚¤ì›Œë“œ ë§¤ì¹­ + ë²¡í„° ê²€ìƒ‰ìœ¼ë¡œ ì„±ëŠ¥ê³¼ ì •í™•ë„ ê· í˜•
2. `ì„ë² ë”© ê´€ë¦¬`: ë°ì´í„° ë³€ê²½ ì‹œ ìë™ ì¬ìƒì„±ìœ¼ë¡œ ìµœì‹ ì„± ìœ ì§€
3. `ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ`: ì‹¤ì‹œê°„ í…ìŠ¤íŠ¸ ì „ë‹¬ë¡œ ì‚¬ìš©ì ê²½í—˜ í–¥ìƒ

ì´ëŸ¬í•œ RAG ì‹œìŠ¤í…œì„ í†µí•´ ë‹¨ìˆœíˆ ChatGPTë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, `ì œ ê°œì¸ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì •í™•í•˜ê³  ìì—°ìŠ¤ëŸ¬ìš´ ë‹µë³€`ì„ ì œê³µí•  ìˆ˜ ìˆê²Œ ë˜ì—ˆì–´ìš”!

ì‹¤ì œ ë™ì‘ì€ [ë“€ë“€ Dev](https://www.dewdew.dev)ì—ì„œ ì‚¬ìš©í•˜ì‹¤ ìˆ˜ ìˆì–´ìš”!
ê¶ê¸ˆí•œ ì ì´ ìˆìœ¼ì‹œë©´ ì–¸ì œë“ ì§€ ì—°ë½ ì£¼ì„¸ìš”!

ê·¸ëŸ¼ ë‹¤ìŒì—ë„ ì¢‹ì€ ê¸€ë¡œ ì°¾ì•„ëµ ìˆ˜ ìˆë„ë¡ í• ê²Œìš”!

ë‹¤ìŒ ê¸€ì—ì„œ ë´¬ìš”!

---

### ì°¸ê³  ë¬¸ì„œ

- [Nuxt 4](https://nuxt.com/)
- [Supabase Edge Functions](https://supabase.com/docs/guides/functions)
- [OpenAI Embeddings API](https://platform.openai.com/docs/guides/embeddings)
- [RAG (Retrieval-Augmented Generation)](https://www.promptingguide.ai/techniques/rag)

